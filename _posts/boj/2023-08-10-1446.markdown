---
layout: post
title: ì§€ë¦„ê¸¸ - 1446
subtitle: ì‹¤ë²„ 1/ì§€ë¦„ê¸¸
categories: [BOJ]
use_math: true
---

## ğŸ“‘ë¬¸ì œë§í¬

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/1446)

## â³íšŒê³ 

ì²˜ìŒ ë¬¸ì œë¥¼ ì½ì—ˆì„ ë•Œ ìœ íš¨í•œ í’€ì´ë¥¼ ìƒê°í•˜ì§€ ëª»í•´ ì•Œê³ ë¦¬ì¦˜ ë¶„ë¥˜ë¥¼ ë³´ê³  ë‹¤ìµìŠ¤íŠ¸ë¼ì¸ ê²ƒì„ í™•ì¸í•˜ê³  ë¬¸ì œë¥¼ í’€ì—ˆë‹¤.

ìœ íš¨í•œ ì§€ë¦„ê¸¸ì„ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•˜ê³  ì €ì¥í•œ ì§€ë¦„ê¸¸ë“¤ê³¼ ì‹œì‘ì§€ì ($0$) ì¢…ë£Œì§€ì ($D$)ì„ ë…¸ë“œë¡œ ìƒê°í•˜ê³  ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•´ í’€ì—ˆë‹¤.

ë‚˜ëŠ” ì–´ë µê²Œ ìƒê°í•´ì„œ ì½”ë“œë¥¼ ì‘ì„±í–ˆì§€ë§Œ í›¨ì”¬ ë¹ ë¥´ê³  ê°„í¸í•˜ê²Œ í•´ê²°í•˜ëŠ” ë°©ë²•ì´ ìˆì—ˆë‹¤.

 ì§€ë¦„ê¸¸ì˜ ì¢…ë£Œì§€ì ì„ í‚¤ë¡œ ì‹œì‘ì§€ì ê³¼ ì§€ë¦„ê¸¸ì˜ ê¸¸ì´ë¥¼ ì›ì†Œë¡œ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ë¥¼ ê°’ìœ¼ë¡œ ê°€ì§„ `Map`ì„ ë§Œë“¤ê³  $0$ë¶€í„° ìµœëŒ€ê¸¸ì´($10000$)ê¹Œì§€ dpë¥¼ ì§„í–‰í•˜ì—¬ í•´ê²°í•œ í’€ì´ê°€ êµ‰ì¥íˆ ë¹ ë¥¸ ê²°ê³¼ë¥¼ ê°€ì ¸ì™”ë‹¤. ë˜‘ë˜‘í•œ ì‚¬ëŒë“¤ì´ ì°¸ ë§ì€ ê²ƒ ê°™ë‹¤. ë¹ ë¥´ê³  ê°„ë‹¨í•œ dp [í’€ì´ ì½”ë“œëŠ” ì—¬ê¸°ë¥¼ í´ë¦­](https://www.acmicpc.net/source/64839813)

## ğŸ’»ì½”ë“œ

```java
import java.util.*;

public class Main {
    public static class ShortCut {
        int start;
        int end;
        int distance;

        public ShortCut (int start, int end, int distance) {
            this.start = start;
            this.end = end;
            this.distance = distance;
        }
    }

    public static class Node {
    	int index;
    	int weight;

    	public Node (int index, int weight) {
    		this.index = index;
    		this.weight = weight;
    	}

    	@Override
		public boolean equals(Object n) {
    		Node node = (Node) n;
    		return node.index == this.index && node.weight == this.weight;
    	}

    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int D = sc.nextInt();
        sc.nextLine();
        Map<Integer, Integer> nodeInfo = new HashMap<>();
        Map<Integer, Integer> nodeKey = new HashMap<>();

        List<ShortCut> shortcutList = new ArrayList<>();
        List<ArrayList<Node>> graph = new ArrayList<>();

	// ìœ íš¨í•œ ì§€ë¦„ê¸¸ ì„ ë³„
        for(int i = 0; i < N; ++i) {

            int start = sc.nextInt();
            int end = sc.nextInt();
            int distance = sc.nextInt();
            sc.nextLine();
            if(end <= D && end - start > distance) {
                shortcutList.add(new ShortCut(start, end, distance));        
            }
        }

        shortcutList.sort(
            (o1, o2) -> o1.start == o2. start ? o1.end - o2.end : o1.start - o2.start
        );

        if(shortcutList.isEmpty()) {
        	System.out.println(D);
        } else {

          for(int i = 0; i < 2; ++i) {
              graph.add(new ArrayList<>());
          }

        	int index = 0;
        	nodeInfo.put(index, 0);
        	nodeKey.put(0, index);
        	nodeInfo.put(++index, D);
        	nodeKey.put(D, index);

		// ê·¸ë˜í”„ ìƒì„±
        	for(int i = 0; i < shortcutList.size(); ++i) {
        		int from = 0;
        		int to = 0;

        		if(nodeKey.get(shortcutList.get(i).start) == null) {
        			nodeInfo.put(++index, shortcutList.get(i).start);
        			nodeKey.put(shortcutList.get(i).start, index);
        			graph.add(new ArrayList<>());
        			from = index;
        		} else {
        			from = nodeKey.get(shortcutList.get(i).start);
        		}

        		if(nodeKey.get(shortcutList.get(i).end) == null) {
        			nodeInfo.put(++index, shortcutList.get(i).end);
        			nodeKey.put(shortcutList.get(i).end, index);
        			graph.add(new ArrayList<>());
        			to = index;
        		} else {
        			to = nodeKey.get(shortcutList.get(i).end);
        		}

        		graph.get(from).add(new Node(to, shortcutList.get(i).distance));

        		for(int j = 0; j < index; ++j) {
        			int jWeight = nodeInfo.get(j);
        			int fromWeight = nodeInfo.get(from);
        			int toWeight = nodeInfo.get(to);

        			if(jWeight > fromWeight) {
        				Node fromNode = new Node(j, jWeight - fromWeight);
        				if(!graph.get(from).contains(fromNode)) {
        					graph.get(from).add(fromNode);
        				}
        			} else if(jWeight < fromWeight) {
        				Node fromNode = new Node(from, fromWeight -jWeight);
        				if(!graph.get(j).contains(fromNode)) {
        					graph.get(j).add(fromNode);
        				}
        			}

        			if(jWeight > toWeight) {
        				Node toNode = new Node(j, jWeight - toWeight);
        				if(!graph.get(to).contains(toNode)) {
        					graph.get(to).add(toNode);
        				}
        			} else if(jWeight < toWeight) {
        				Node toNode = new Node(to, toWeight - jWeight);
        				if(!graph.get(j).contains(toNode)) {
        					graph.get(j).add(toNode);
        				}
        			}
        		}
        	}

        	int[] dist = dijkstra(nodeKey.size(), graph, 0);
        	System.out.println(dist[1]);
        }

        sc.close();
    }

    private static int[] dijkstra(int size, List<ArrayList<Node>> graph, int startIndex) {
        int[] dist = new int[size];
        Arrays.fill(dist, Integer.MAX_VALUE);
        boolean[] visited = new boolean[size];
        dist[startIndex] = 0;

        for(int i = 0; i < size; i++) {
            int nodeWeight = Integer.MAX_VALUE;
            int node = 0;

            for(int j = 0; j < size; j++) {
                if(!visited[j] && (dist[j] < nodeWeight)) {
                    nodeWeight = dist[j];
                    node = j;
                }
            }

            visited[node] = true;
            for(int j = 0; j < graph.get(node).size(); j++) {
                Node adjNode = graph.get(node).get(j);

                dist[adjNode.index] = Math.min(dist[adjNode.index], dist[node] + adjNode.weight);
            }
        }

        return dist;
    }
}
```